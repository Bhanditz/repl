'use strict';

const fs = require('fs');
const ts = require('typescript');

const HasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);

const program = ts.createProgram([
  require.resolve('typescript/lib/lib.esnext.d.ts'),
], { noLib: true });

const annotationMap = new Map();

function parseTSFunction(receiver, func) {
  let namespace;
  let key = receiver;
  if (/Constructor$/.test(receiver)) {
    namespace = global[receiver.replace(/Constructor$/, '')];
    key = namespace.name;
  } else if (HasOwnProperty(global, receiver)) {
    namespace = global[receiver];
    if (namespace && namespace.prototype) {
      namespace = namespace.prototype;
      key = `${receiver}.prototype`;
    }
  } else {
    return;
  }

  const method = namespace[func.name.escapedText];
  if (!method) {
    return;
  }

  key = `${key}.${func.name.escapedText}`;

  const args = func.parameters
    .map((p) => {
      let text = p.name.escapedText;
      if (p.questionToken) {
        text = `?${text}`;
      }
      if (p.dotDotDotToken) {
        text = `...${text}`;
      }
      return text;
    })
    .filter((x) => x !== 'this');

  if (annotationMap.has(key)) {
    annotationMap.get(key).push(args);
  } else {
    annotationMap.set(key, [args]);
  }
}

program.getSourceFiles().forEach((file) => {
  ts.forEachChild(file, (node) => {
    if (node.kind === ts.SyntaxKind.InterfaceDeclaration) {
      for (const member of node.members) {
        if (member.kind === ts.SyntaxKind.MethodSignature) {
          parseTSFunction(node.name.text, member);
        }
      }
    } else if (node.kind === ts.SyntaxKind.FunctionDeclaration) {
      parseTSFunction('global', node);
    } else if (node.kind === ts.SyntaxKind.ModuleDeclaration) {
      const receiver = node.name.escapedText;
      for (const statement of node.body.statements) {
        if (statement.kind === ts.SyntaxKind.FunctionDeclaration) {
          parseTSFunction(receiver, statement);
        }
      }
    } else {
      // console.log(Object.entries(ts.SyntaxKind).find(e => e[1] === node.kind), node);
    }
  });
});

annotationMap.set('global.queueMicrotask', [['callback']]);

const out = [];
for (const [key, value] of annotationMap) {
  if (value.length === 1 && value[0].length === 0) {
    continue; // eslint-disable-line no-continue
  }
  out.push(`  [${key}, ${JSON.stringify(value)}]`);
}

fs.writeFileSync('./src/annotation_map.js', `'use strict';

/* eslint-disable */

// Generated by generate_annotations.js
// This file maps native methods to their signatures for completion
// in the repl. if a method isn't listed here, it is either unknown
// to the generator script, or it doesn't take any arguments.

module.exports = new WeakMap([
${out.join(',\n')},
]);
`);
